# IPC（进程间通信）

## 管道

半双工管道（即数据只能在一个方向上流动）

管道是由内核管理的一个缓冲区，相当于我们放入内存中的一个纸条。首先在**内核**中开辟一块缓冲区用于通信，它有一个读端和一个写端，然后通过fd参数传出给用户进程两个文件描述符，fd[0]指向管道的读端，fd[1]指向管道的写段，管道只能在**具有公共祖先**的两个进程之间使用个，通常，一个管道由一个进程创建，在进程调用fork之后，这个管道就能在父进程和子进程之间使用了。

```c
#include <unistd.h>
int pipe(int fd[2]);    // 返回值：若成功返回0，失败返回-1
```



**注意**以下四种情况

- **没写端，读返回0，文件结尾**，如果所有指向管道写端的文件描述符都关闭了，而仍然有进程从管道的读端读数据，那么文件内的所有内容被读完后再次**read就会返回0**，就像读到**文件结尾**。
- **有写端，读等写**，如果有指向管道写端的文件描述符没有关闭（管道写段的引用计数大于0），而持有管道写端的进程没有向管道内写入数据，假如这时有进程从管道读端读数据，那么读完管道内剩余的数据后就会**阻塞等待**，直到有数据可读才读取数据并返回。
- **没读端，写收到信号，报错**，如果所有指向管道读端的文件描述符都关闭，此时有进程通过写端文件描述符向管道内写数据时，则该进程就会**收到SIGPIPE信号**，并异常终止。
- **有读，但未读，写满，写阻塞**，如果有指向管道读端的文件描述符没有关闭（管道读端的引用计数大于0），而持有管道读端的进程没有从管道内读数据，假如此时有进程通过管道写段写数据，那么管道被**写满后就会被阻塞**，直到管道内有空位置后才写入数据并返回。



## 命名管道

FIFO有时被称为命名管道。未命名的管道只能在两个相关的进程之间使用，而且这两个相关的进程还要有一个共同的创建了它们的祖先进程。但是通过FIFO，不相关的进程也能交换数据。

```c
#include <sys/types.h>
#include <sys/stat.h>
int mkfifo(const char *filename, mode_t mode);
```

其中pathname是被创建的文件名称，mode表示将在该文件上设置的权限位和将被创建的文件类型(在此情况下为S_IFIFO)

**返回值**

```
成功：0
失败：如果文件已经存在，则会出错且返回 -1。
```

单独以只读或者只写方式打开FIFO，都会等待另一个进程使用open

open() 以只读方式打开 FIFO 时，要**阻塞**到某个进程为写而打开此 FIFO
open() 以只写方式打开 FIFO 时，要**阻塞**到某个进程为读而打开此 FIFO。只有两个都执行到，才会往下执行。

